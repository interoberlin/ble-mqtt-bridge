/**
 * @file
 * Reads a floorsensor configuration file and proceeds by
 * connecting to all configured BLE beacons.
 * Received values are published to an MQTT broker.
 */

#include <iostream>
#include <fstream>
#include <vector>
#include <stddef.h>
#include <unistd.h>
#include <chrono>
#include <thread>
#include <pthread.h>
#include <time.h>
#include <getopt.h>
#include <stdlib.h>

#include "floorsensord/Config.hpp"
#include "floorsensord/ValueSplitter.hpp"
#include "endpoints/BLEClient.hpp"
#include "endpoints/MQTTClient.hpp"
#include "events/Event.hpp"
#include "events/EventReceiver.hpp"
#include "events/EventGenerator.hpp"

#include "debug.h"

using namespace std;
using namespace std::chrono_literals;
using namespace floorsensord;


/*
 * Command line option global vars
 */

/** Debug level */
debug_flags debug_flag = DEBUG_NONE;

/** Print configuration check and exit? */
bool config_check_flag = false;

/** Filename from which to read configuration */
string config_filename = "floorsensor_config.json";


/*
 * Variables for device bridging
 */

/** All values are read from BLE beacons, one object per beacon. */
vector<BLEClient*> beacons;

/** The beacon and sensor configuration is read from a JSON file. */
Config config;

/** The values read from a beacon are passed to a splitter. */
vector<ValueSplitter*> splitters;

/** The values generated by the splitters are passed to one single MQTT publisher. */
MQTTClient* mqtt;


void bridge_floorsensor(json config)
{

    struct bridge_t {
        std::string mqttClientName;
        std::string mqttTopic;
        std::string mqttHost;
        int mqttPort;
        BLEClientRole::role_enum bleClienRole;
        std::string bleAddress;
        std::string bleOwner;
        std::string bleLocation;
        std::string bleService;
        std::string bleCharacteristic;
    } bridge_config;


    bridge_config.bleClienRole = BLEClientRole::READER;
    bridge_config.bleService = floorsensord::UUID_SERVICE;
    bridge_config.bleCharacteristic = floorsensord::UUID_CHARACTERISTIC3;

    //  parse the json-config
    for (uint beacon = 0; beacon < config["beacons"].size(); beacon++) {

        bridge_config.bleAddress = config["beacons"][beacon]["address"];
        bridge_config.bleOwner   = config["beacons"][beacon]["owner"];
        bridge_config.bleLocation= \
                config["beacons"][beacon]["location"].empty()?\
                "NotDefined":\
                config["beacons"][beacon]["location"];

        if ( debug_flag > DEBUG_MORE ) {
            cout << " " << beacon << ": [" << bridge_config.bleAddress << "]"
                 << " " << "[" << bridge_config.bleOwner << "]"
                 << " " << "[" << bridge_config.bleLocation << "]"  << endl << flush;
        }

        for (uint sensor = 0; sensor < config["beacons"][beacon]["sensors"].size(); sensor++) {

           bridge_config.mqttTopic = config["beacons"][beacon]["sensors"][sensor]["topic"];

           if ( debug_flag > DEBUG_MORE ) {
                cout << "    " << sensor << ": [" << bridge_config.mqttTopic << "]" << endl << flush;
           }
        } // sensor

        try {
            if ( debug_flag > DEBUG_NORMAL ) {
                cout << ">> define " << bridge_config.bleAddress << "->" << bridge_config.mqttTopic << endl << flush;
            }


        } catch (exception& e) {
            cerr << e.what();
        }

    } // beacon

}


/**
 * Parse and interpret command line arguments
 */
void parseArgs(int argc, char* argv[])
{
    int option_char;

    while ((option_char = getopt (argc, argv, "cd:f:?")) != EOF) {
        switch (option_char) {
            case 'd': {
                char* end_p = NULL;
                errno = 0;
                long temp_val = strtol(optarg, &end_p, 10);
                if (end_p != optarg && errno != ERANGE && temp_val >= DEBUG_NONE && temp_val <= DEBUG_ALL) {
                    debug_flag = (debug_flags) temp_val;
                }
            } break;
            case 'c': 
                config_check_flag = true; 
                debug_flag = DEBUG_ALL; 
                break;
            case 'f': 
                config_filename = optarg;
                break;
            case '?':
                 cerr << "usage: " << argv[0] << " [cf<val>d<val>]" << endl; break;
        }
    }
}


int main(int argc, char* argv[])
{
    parseArgs(argc, argv);

    Config config;
    config.importJSON(config_filename);

    if (config_check_flag)
    {
        config.printCheck();
    }
    else
    {
        // Create a BLEClient for every configured beacon
        config.generateBeacons(beacons);

        // Create an MQTT publisher
        mqtt = new MQTTClient(
                        "floorsensord",
                        "floorsensor",
                        "localhost",
                        1883
                        );

        // Create a floorsensor value splitter, that publishes to MQTT
        config.generateValueSplitters(splitters, mqtt);

        // At this point all activity is event-driven

        // Sleep until a signal arrives
        pause();

        // Cleanup: Delete created objects
        for (vector<BLEClient*>::iterator it = beacons.begin(); it != beacons.end(); ++it)
        {
            delete *it;
        }
        for (vector<ValueSplitter*>::iterator it = splitters.begin(); it != splitters.end(); ++it)
        {
            delete *it;
        }
        delete mqtt;
    } // config_check_flag
}
